<!DOCTYPE html>
<html>

<head>
  <title>PGX Top to Bottom</title>
  <meta charset="utf-8">
  <style>
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body {
      font-family: 'Droid Serif';
    }

    h1,
    h2,
    h3 {
      font-family: 'Yanone Kaffeesatz';
      font-weight: normal;
    }

    .remark-code,
    .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }
  </style>
</head>

<body>
  <textarea id="source">

class: center, middle

# PGX Top to Bottom

29 Aug 2023

Jack Christensen

---

# Introduction

* Topic - advanced usage and architecture of pgx
* Target Audience - intermediate to advanced Go and PostgreSQL users
* Goal - everyone learns something they can use

Questions are welcome!

---

# Primary Packages

* stdlib - `database/sql` compatibility
* pgxpool - connection pool
* pgx - primary interface for a single connection
* pgtype - type conversions between Go and PostgreSQL types
* pgconn - low-level connection interface similar to the C libpq library
* pgproto3 - wire protocol encoding and decoding

---

# stdlib - basics

```go
package main

import (
	"database/sql"
	"fmt"
	"log"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
)

func main() {
	db, err := sql.Open("pgx", os.Getenv("DATABASE_URL"))
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	var n int32
	err = db.QueryRow("select 42").Scan(&n)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(n)
}
```

---

# stdlib - pgx types as query parameters

Anything value the pgx driver can use can also be used through `database/sql`.

```go
	_, err = db.ExecContext(ctx, `
	create temporary table t (
		id int primary key generated by default as identity,
		data int[] not null
	)`)
	if err != nil {
		log.Fatal(err)
	}

	// Query arguments are passed directly to the underlying pgx conn so there is
	// no need to implement driver.Valuer if pgx already understands the type.
	_, err = db.ExecContext(ctx,
		`insert into t (data) values ($1)`,
		[]int32{1, 2, 3},
	)
	if err != nil {
		log.Fatal(err)
	}
```

---

# stdlib - pgx types as scan targets

```go
	// Scanning requires the use of an adapter.
	m := pgtype.NewMap()
	var data []int32
	err = db.QueryRow("select data from t limit 1").Scan(m.SQLScanner(&data))
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(data) // => [1 2 3]
```

Scanning through database/sql is limited by the sql.Scanner interface. The
underlying PostgreSQL type is lost. The underlying text or binary format is lost
as well. This means many types that pgx supports in binary format fall back to
text format when running through `database/sql`.

* `*pgtype.Map` needed as adapter
* Scan targets that have multiple possible PostgreSQL types will not work. For
example, `map[string]any` could come from PostgreSQL `json`, `jsonb`, or
`hstore`.
* Generic types such as `Array[T]` may not work.

---

# stdlib - custom connection config

```go
config, err := pgx.ParseConfig(os.Getenv("DATABASE_URL"))
if err != nil {
  log.Fatal(err)
}

config.OnNotice = func(c *pgconn.PgConn, n *pgconn.Notice) {
  log.Printf("PID: %d; Message: %s\n", c.PID(), n.Message)
}

db := stdlib.OpenDB(*config)
defer db.Close()

_, err = db.Exec("drop table if exists foo")
if err != nil {
  log.Fatal(err)
}

// config.OnNotice prints:
// => 2023/08/24 20:42:44 PID: 86890; Message: table "foo" does not exist, skipping
```

* `OpenDB` is simplest interface for customizing connection config
* `stdlib.RegisterConnConfig` is also available when using a 3rd party wrapper
that internally calls `sql.Open`.
---
---
---
---
---
---
---
---



## TODO

get pgx connection from database/sql
stdlib doesn't get any special access

CollectRows / RowTo interface

Nested structs vs batching

    </textarea>
  <script src="https://remarkjs.com/downloads/remark-latest.min.js">
  </script>
  <script>
    var slideshow = remark.create();
  </script>
</body>

</html>
